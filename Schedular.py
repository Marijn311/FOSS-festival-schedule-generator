# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Cu7Q8ukG7AzWbNE0WsY3HRB482a9nS66
"""



def schedule_shows(shows):
    """
    Schedule the shows to the minimum number of stages required.

    Parameters:
    shows (list of tuples): A list where each tuple contains the show name, start, and end time.

    Returns:
    list of tuples: A list of tuples with show name, start time, end time, and assigned stage.
    int: The minimum number of stages required.
    """
    # Sort shows by start time (and by end time as a tie-breaker)
    shows.sort(key=lambda x: (x[1], x[2]))

    # Track the stage assignment and available stages
    stage_assignments = [] # List of tuples for all the scheduled shows (show_name, start_time, end_time, assigned_stage)
    stages_end_times = []  # List to track the end times of currently occupied stages
    stage_count = 0        # Number of stages minimally needed to make the schedule

    # Loop over all shows and assign them to a stage
    for show in shows:
        show_name, start_time, end_time = show

        # Find a stage that is free (where the last show ends before the current show starts)
        assigned_stage = None
        for i in range(len(stages_end_times)):
            if stages_end_times[i] < start_time:
                assigned_stage = i + 1
                stages_end_times[i] = end_time
                break

        # If the search for a free existing stage fails, increase the number of stages.
        if assigned_stage is None:
            stage_count += 1
            assigned_stage = stage_count
            stages_end_times.append(end_time)
        else:
            # Update the end time for the assigned stage
            stages_end_times[assigned_stage - 1] = end_time

        # Assign the stage to the current show
        stage_assignments.append((show_name, start_time, end_time, assigned_stage))

    return stage_assignments, stage_count


def print_schedule(shows):
    """
    Print a schedule table where stages are on the x-axis and hours on the y-axis.

    Parameters:
    shows (list of tuples): A list where each tuple contains the show name, start, and end time.
    """
    # Schedule the shows and get the stage assignments
    scheduled_shows, stages_needed = schedule_shows(shows)

    # Determine the range of hours (y-axis)
    min_time = min(show[1] for show in scheduled_shows)
    max_time = max(show[2] for show in scheduled_shows)

    # Create the schedule matrix
    schedule_matrix = [["" for _ in range(stages_needed)] for _ in range(min_time, max_time + 1)]

    # Fill in the schedule matrix with show names
    for show_name, start_time, end_time, stage in scheduled_shows:
        for hour in range(start_time, end_time + 1):
            schedule_matrix[hour - min_time][stage - 1] = show_name

    # Print the table header
    print(f"{'Hour':<5}", end="")
    for stage in range(1, stages_needed + 1):
        print(f"Stage {stage:<10}", end="")
    print("\n" + "-" * (7 + stages_needed * 12))

    # Print the schedule matrix
    for hour, row in enumerate(schedule_matrix, start=min_time):
        print(f"{hour:<5}", end="")
        for cell in row:
            print(f"{cell:<10}", end="")
        print()


# Example usage:
shows = [
    ("show_1", 36, 39),
    ("show_2", 30, 33),
    ("show_3", 29, 36),
    ("show_4", 40, 45),
    ("show_5", 32, 38),
]

print_schedule(shows)